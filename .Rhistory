#### such as products that are not chips
transactionData$PROD_SIZE <- gsub(".{4}$", "", transactionData$PROD_NAME)
#### Examine the words in PROD_NAME to see if there are any incorrect entries
#### such as products that are not chips
transactionData$PROD_SIZE <-gsub(".*_(\\d+)\\..*", "\\1", transactionData$PROD_NAME)
#### Examine the words in PROD_NAME to see if there are any incorrect entries
#### such as products that are not chips
transactionData$PROD_SIZE <-gsub(".*_(\\d+)\\..*", "\\1", transactionData$PROD_NAME)
#### Examine the words in PROD_NAME to see if there are any incorrect entries
#### such as products that are not chips
transactionData$PROD_SIZE <-strsplit(".*_(\\d+)\\..*", "\\1", transactionData$PROD_NAME)
#### Examine the words in PROD_NAME to see if there are any incorrect entries
#### such as products that are not chips
transactionData$PROD_SIZE <-sub("\\.+$", "",transactionData$PROD_NAME)
#### Examine the words in PROD_NAME to see if there are any incorrect entries
#### such as products that are not chips
transactionData$PROD_SIZE <-sub("\\{4}$", "",transactionData$PROD_NAME)
#### Examine the words in PROD_NAME to see if there are any incorrect entries
#### such as products that are not chips
transactionData$PROD_SIZE <-sub("\\{4}+$", "",transactionData$PROD_NAME)
#### Examine the words in PROD_NAME to see if there are any incorrect entries
#### such as products that are not chips
transactionData$PROD_SIZE <- substrRight(4,transactionData$PROD_NAME)
#### Examine the words in PROD_NAME to see if there are any incorrect entries
#### such as products that are not chips
transactionData$PROD_SIZE <- str_sub(transactionData$PROD_NAME, -4,-1)
gsub('.{4}$', '', transactionData$PROD_NAME)
transactionData$PROD_NAME <- gsub('.{4}$', '', transactionData$PROD_NAME)
#### Examine PROD_NAME
summary(transactionData$PROD_NAME)
#### Examine PROD_NAME
transactionData[, .N, PROD_NAME]
productWords <- data.table(unlist(strsplit(unique(transactionData[, PROD_NAME]), "")))
setNames(productWords, "words")
# Over to you! Remove digits, and special characters, and then sort the distinct
#words by frequency of occurrence.
#### Removing digits
productWords <- productWords[grepl("\\d", words) == FALSE, ]
# Over to you! Remove digits, and special characters, and then sort the distinct
#words by frequency of occurrence.
#### Removing digits
productWords <- productWords[grepl("[:alpha:]", words), ]
#### Removing digits
productWords[,SPECIAL := grepl("[[:digit:]]",words)]
productWords <- data.table(unlist(strsplit(unique(transactionData[,"PROD_NAME"])," ")))
# set options for R markdown knitting
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(linewidth=80)
# set up line wrapping in MD knit output
library(knitr)
hook_output = knit_hooks$get("output")
knit_hooks$set(output = function(x, options)
{
# this hook is used only when the linewidth option is not NULL
if (!is.null(n <- options$linewidth))
{
x = knitr:::split_lines(x)
# any lines wider than n should be wrapped
if (any(nchar(x) > n))
x = strwrap(x, width = n)
x = paste(x, collapse = "\n")
}
hook_output(x, options)
})
#### Example code to install packages
#install.packages("data.table")
#### Load required libraries
library(data.table)
library(ggplot2)
library(ggmosaic)
library(readr)
library(readxl)
library(dplyr)
library(stringr)
#### Point the filePath to where you have downloaded the datasets to and
#### assign the data files to data.tables
transactionData <- data.table(read_excel("QVI_transaction_data.xlsx"))
customerData <- fread("QVI_purchase_behaviour.csv")
#### Examine transaction data
str(transactionData)
#### Convert DATE column to a date format
#### A quick search online tells us that CSV and Excel integer dates begin on 30Dec 1899
transactionData$DATE <- as.Date(transactionData$DATE, origin = "1899-12-30")
#### Examine transaction data
head(transactionData)
#### Examine PROD_NAME
transactionData[, .N, PROD_NAME]
productWords <- data.table(unlist(strsplit(unique(transactionData[,"PROD_NAME"])," ")))
# set options for R markdown knitting
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(linewidth=80)
# set up line wrapping in MD knit output
library(knitr)
hook_output = knit_hooks$get("output")
knit_hooks$set(output = function(x, options)
{
# this hook is used only when the linewidth option is not NULL
if (!is.null(n <- options$linewidth))
{
x = knitr:::split_lines(x)
# any lines wider than n should be wrapped
if (any(nchar(x) > n))
x = strwrap(x, width = n)
x = paste(x, collapse = "\n")
}
hook_output(x, options)
})
#### Example code to install packages
#install.packages("data.table")
#### Load required libraries
library(data.table)
library(ggplot2)
library(ggmosaic)
library(readr)
library(readxl)
library(dplyr)
library(stringr)
#### Point the filePath to where you have downloaded the datasets to and
#### assign the data files to data.tables
transactionData <- data.table(read_excel("QVI_transaction_data.xlsx"))
customerData <- fread("QVI_purchase_behaviour.csv")
#### Examine transaction data
str(transactionData)
#### Convert DATE column to a date format
#### A quick search online tells us that CSV and Excel integer dates begin on 30Dec 1899
transactionData$DATE <- as.Date(transactionData$DATE, origin = "1899-12-30")
#### Examine transaction data
head(transactionData)
#### Examine PROD_NAME
transactionData[, .N, PROD_NAME]
productWords <- data.table(unlist(strsplit(unique(transactionData[,"PROD_NAME"])," ")))
productWords <- data.table(unlist(strsplit(unique(transactionData[, PROD_NAME]), " ")))
setnames(productWords, 'words')
#### Examine the words in PROD_NAME to see if there are any incorrect entries
#### such as products that are not chips
transactionData$PROD_SIZE <- str_sub(transactionData$PROD_NAME, -4,-1)
transactionData$PROD_NAME <- gsub('.{4}$', '', transactionData$PROD_NAME)
#### Removing digits
productWords[,SPECIAL := grepl("[[:digit:]]",words)]
#### Removing special characters
#### Let's look at the most common words by counting the number of times a word
#appears and
#### sorting them by this frequency in order of highest to lowest frequency
productWords <- productWords[SPECIAL == FALSE,][,SPECIAL := NULL]
View(productWords)
#### Removing special characters
productWords[,SPECIAL := grepl("[[:punct:]]",words)]
productWords <- productWords[SPECIAL == FALSE,][,SPECIAL := NULL]
#### Removing digits
productWords[,SPECIAL := grepl("[[:digit:]]",words)]
productWords <- productWords[SPECIAL == FALSE,][,SPECIAL := NULL]
#### Removing special characters
productWords[,SPECIAL := grepl("[[:punct:]]",words)]
productWords <- productWords[SPECIAL == FALSE,][,SPECIAL := NULL]
#### changing empty string to NA
productWords[words == ""] <- NA
#### removing all empty cells
productWords <- productWords[complete.cases(productWords),]
#### Let's look at the most common words by counting the number of times a word
#appears and
#### sorting them by this frequency in order of highest to lowest frequency
productWords <- data.frame(sort(table(productWords),decreasing = TRUE))
View(productWords)
#### Remove salsa products
transactionData[, SALSA := grepl("salsa", tolower(PROD_NAME))]
transactionData <- transactionData[SALSA == FALSE, ][, SALSA := NULL]
#### Summarise the data to check for nulls and possible outliers
summary(transactionData)
#### Summarise the data to check for nulls and possible outliers
summary(transactionData)
sum(is.na(transactionData))
View(transactionData)
#### Filter the dataset to find the outlier
outlier <- transactionData[PROD_QTY == 200,]
#### Let's see if the customer has had other transactions
outlierTransactions <- transactionData[LYLTY_CARD_NBR == 226000,]
View(outlierTransactions)
#### Filter out the customer based on the loyalty card number
outlierTransactions <- transactionData[LYLTY_CARD_NBR == 226000,]
#### Re-examine transaction data
numberOfTransactionsByDate <- data.frame(sort(table(transactionData$DATE),decreasing = TRUE ))
#### Re-examine transaction data
numberOfTransactionsByDate <- data.frame(sort(table(transactionData$DATE),decreasing = TRUE ))
setnames(numberOfTransactionsByDate,c('date','freq'))
numberOfTransactionsByDate<-numberOfTransactionsByDate[order(as.Date(numberOfTransactionsByDate$date)),]
View(numberOfTransactionsByDate)
#### Count the number of transactions by date
unique(transactionData$DATE)
summary(transactionData$DATE)
#### Count the number of transactions by date
unique(transactionData$DATE)
summary(transactionData$DATE)
#### Create a sequence of dates and join this the count of transactions by date
# Over to you - create a column of dates that includes every day from 1 Jul 2018 to
#30 Jun 2019, and join it onto the data to fill in the missing day.
seqOfDates <- data.table(seq(as.Date('2018-07-01'),as.Date('2019-06-30'),by = 1))
setnames(seqOfDates,"date")
seqOfDates$date <- as.factor(seqOfDates$date)
class(numberOfTransactionsByDate$date)
transactions_by_day <- merge (x = seqOfDates, y = numberOfTransactionsByDate, by="date", all.x = TRUE)
transactions_by_day$date <- as.Date(transactions_by_day$date)
#### Setting plot themes to format graphs
theme_set(theme_bw())
theme_update(plot.title = element_text(hjust = 0.5))
#### Plot transactions over time
ggplot(transactions_by_day, aes(x = DATE, y = N)) +
geom_line() +
labs(x = "Day", y = "Number of transactions", title = "Transactions over time") +
scale_x_date(breaks = "1 month") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
#### Setting plot themes to format graphs
theme_set(theme_bw())
theme_update(plot.title = element_text(hjust = 0.5))
#### Plot transactions over time
ggplot(transactions_by_day, aes(x = date, y = freq)) +
geom_line() +
labs(x = "Day", y = "Number of transactions", title = "Transactions over time") +
scale_x_date(breaks = "1 month") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
#### Filter to December and look at individual days
december <- transactions_by_day[transactions_by_day$date >= as.Date("2018-12-01") & transactions_by_day$date <= as.Date("2018-12-31"),]
#### plotting transactions over december
ggplot(december,aes(x=date,y= freq)) +
geom_line() +
labs(x = "Day", y ="Number of transactions",title="Transactions over time (December)")+
scale_x_date(breaks = "1 day") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
#### Always check your output
#### Let's check if the pack sizes look sensible
transactionData[, .N, PROD_SIZE][order(PROD_SIZE)]
#### Always check your output
transactionData[, PACK_SIZE := parse_number(PROD_NAME)]
# set options for R markdown knitting
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(linewidth=80)
# set up line wrapping in MD knit output
library(knitr)
hook_output = knit_hooks$get("output")
knit_hooks$set(output = function(x, options)
{
# this hook is used only when the linewidth option is not NULL
if (!is.null(n <- options$linewidth))
{
x = knitr:::split_lines(x)
# any lines wider than n should be wrapped
if (any(nchar(x) > n))
x = strwrap(x, width = n)
x = paste(x, collapse = "\n")
}
hook_output(x, options)
})
#### Example code to install packages
#install.packages("data.table")
#### Load required libraries
library(data.table)
library(ggplot2)
library(ggmosaic)
library(readr)
library(readxl)
library(dplyr)
library(stringr)
#### Point the filePath to where you have downloaded the datasets to and
#### assign the data files to data.tables
transactionData <- data.table(read_excel("QVI_transaction_data.xlsx"))
customerData <- fread("QVI_purchase_behaviour.csv")
#### Examine transaction data
str(transactionData)
#### Convert DATE column to a date format
#### A quick search online tells us that CSV and Excel integer dates begin on 30Dec 1899
transactionData$DATE <- as.Date(transactionData$DATE, origin = "1899-12-30")
#### Examine transaction data
head(transactionData)
#### Examine PROD_NAME
transactionData[, .N, PROD_NAME]
#### Examine the words in PROD_NAME to see if there are any incorrect entries
#### such as products that are not chips
productWords <- data.table(unlist(strsplit(unique(transactionData[, PROD_NAME]), " ")))
setnames(productWords, 'words')
#### Removing digits
productWords[,SPECIAL := grepl("[[:digit:]]",words)]
productWords <- productWords[SPECIAL == FALSE,][,SPECIAL := NULL]
#### Removing special characters
productWords[,SPECIAL := grepl("[[:punct:]]",words)]
productWords <- productWords[SPECIAL == FALSE,][,SPECIAL := NULL]
#### changing empty string to NA
productWords[words == ""] <- NA
#### removing all empty cells
productWords <- productWords[complete.cases(productWords),]
#### Let's look at the most common words by counting the number of times a word
#appears and
#### sorting them by this frequency in order of highest to lowest frequency
productWords <- data.frame(sort(table(productWords),decreasing = TRUE))
#### Remove salsa products
transactionData[, SALSA := grepl("salsa", tolower(PROD_NAME))]
transactionData <- transactionData[SALSA == FALSE, ][, SALSA := NULL]
#### Summarise the data to check for nulls and possible outliers
summary(transactionData)
sum(is.na(transactionData))
#### Filter the dataset to find the outlier
outlier <- transactionData[PROD_QTY == 200,]
#### Let's see if the customer has had other transactions
#### Filter out the customer based on the loyalty card number
outlierTransactions <- transactionData[LYLTY_CARD_NBR == 226000,]
#### Re-examine transaction data
numberOfTransactionsByDate <- data.frame(sort(table(transactionData$DATE),decreasing = TRUE ))
setnames(numberOfTransactionsByDate,c('date','freq'))
numberOfTransactionsByDate<-numberOfTransactionsByDate[order(as.Date(numberOfTransactionsByDate$date)),]
#### Count the number of transactions by date
unique(transactionData$DATE)
summary(transactionData$DATE)
#### Create a sequence of dates and join this the count of transactions by date
# Over to you - create a column of dates that includes every day from 1 Jul 2018 to
#30 Jun 2019, and join it onto the data to fill in the missing day.
seqOfDates <- data.table(seq(as.Date('2018-07-01'),as.Date('2019-06-30'),by = 1))
setnames(seqOfDates,"date")
seqOfDates$date <- as.factor(seqOfDates$date)
class(seqOfDates$date)
class(numberOfTransactionsByDate$date)
transactions_by_day <- merge (x = seqOfDates, y = numberOfTransactionsByDate, by="date", all.x = TRUE)
transactions_by_day[is.na(transactions_by_day)] <- 0
transactions_by_day$date <- as.Date(transactions_by_day$date)
#### Setting plot themes to format graphs
theme_set(theme_bw())
theme_update(plot.title = element_text(hjust = 0.5))
#### Plot transactions over time
ggplot(transactions_by_day, aes(x = date, y = freq)) +
geom_line() +
labs(x = "Day", y = "Number of transactions", title = "Transactions over time") +
scale_x_date(breaks = "1 month") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
#### Filter to December and look at individual days
december <- transactions_by_day[transactions_by_day$date >= as.Date("2018-12-01") & transactions_by_day$date <= as.Date("2018-12-31"),]
#### plotting transactions over december
ggplot(december,aes(x=date,y= freq)) +
geom_line() +
labs(x = "Day", y ="Number of transactions",title="Transactions over time (December)")+
scale_x_date(breaks = "1 day") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
#### Always check your output
transactionData[, PACK_SIZE := parse_number(PROD_NAME)]
#### Let's check if the pack sizes look sensible
transactionData[, .N, PROD_SIZE][order(PROD_SIZE)]
#### Let's check if the pack sizes look sensible
transactionData[, .N, PACK_SIZE][order(PACK_SIZE)]
#### Let's plot a histogram of PACK_SIZE since we know that it is a categorical
#variable and not a continuous variable even though it is numeric.
ggplot(transactionData,aes(x=PACK_SIZE) )+
geom_histogram(binwidth = 10,color="black",fill="lightblue") +scale_x_discrete() +
labs(x = "Pack Sizes", y ="Frequency",title="Histogram of Pack Sizes")+scale_color_brewer(palette="Dark2")+geom_density(alpha=.2, fill="#FF6666") #### mean and standard deviation of pack sizes
mean(transactionData$PACK_SIZE)
sd(transactionData$PACK_SIZE)
#### Brands
transactionData$BRAND_NAME <- sub('(^\\w+)\\s.+','\\1',transactionData$PROD_NAME)
#### Clean brand names
transactionData[BRAND == "RED", BRAND := "RRD"]
#### Brands
transactionData$BRAND_NAME <- sub('(^\\w+)\\s.+','\\1',transactionData$PROD_NAME)
#### Clean brand names
transactionData[BRAND == "RED", BRAND := "RRD"]
#### Clean brand names
transactionData[BRAND == "RED", BRAND := "RRD"]
#### Clean brand names
transactionData[BRAND_NAME == "RED", BRAND_NAME := "RRD"]
transactionData[BRAND_NAME == "GRAIN", BRAND_NAME := "GrnWves"]
transactionData[BRAND_NAME == "INFZNS", BRAND_NAME := "Infuzions"]
transactionData[BRAND_NAME == "WW", BRAND_NAME := "Woolworths"]
transactionData[BRAND_NAME == "SNBTS", BRAND_NAME := "Sunbites"]
#### Check again
brands <- data.frame(sort(table(transactionData$BRAND_NAME),decreasing = TRUE ))
setnames(brands,c("BRAND","freq"))
ggplot(brands,aes(x=BRAND,y= freq,fill=BRAND)) +
geom_bar(stat="identity",width = 0.5) +
labs(x = "Brands", y ="Frequency",title="Distribution Of Brand Purchases")+
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
#### Examining customer data
summary(customerData)
sum(is.na(customerData))
lifestageCategory <- data.frame(sort(table(customerData$LIFESTAGE),decreasing = TRUE ))
setnames(lifestageCategory,c("lifestage","freq"))
ggplot(lifestageCategory,aes(x=lifestage,y= freq,fill=lifestage)) +
geom_bar(stat="identity",width = 0.5) +
labs(x = "lifestage", y ="frequency",title="Distribution Of Customers Over Lifestages")+
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))+scale_fill_brewer(palette="Dark2")
ggplot(lifestageCategory,aes(x=lifestage,y= freq,fill=lifestage)) +
geom_bar(stat="identity",width = 0.5) +
labs(x = "lifestage", y ="frequency",title="Distribution Of Customers Over Lifestages")+
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))+scale_fill_brewer(palette="Dark2")
premiumCustomerType <- data.frame(sort(table(customerData$PREMIUM_CUSTOMER),decreasing = TRUE ))
setnames(premiumCustomerType,c("premium_customer_type","freq"))
ggplot(premiumCustomerType,aes(x=premium_customer_type,y= freq,fill=premium_customer_type)) +
geom_bar(stat="identity",width = 0.5) +
labs(x = "lifestage", y ="frequency",title="Distribution Of Customers Over Premium Types")+
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))+scale_fill_brewer(palette="Dark2")
rge(transactionData, customerData, all.x = TRUE)
#### Merge transaction data to customer data
data <- merge(transactionData, customerData, all.x = TRUE)
sum(is.na(data))
fwrite(data, paste0(filePath,"QVI_data.csv"))
fwrite(data, paste0("QVI_data.csv"))
fwrite(data, "QVI_data.csv")
#### Total sales by LIFESTAGE and PREMIUM_CUSTOMER
totalSalesByLifestage <- aggregate(data$TOT_SALES, by=list(LIFESTAGE=data$LIFESTAGE),FUN=sum)
setnames(totalSalesByLifestage,c("Lifestage","Total_Sales"))
totalSalesByLifestage<-totalSalesByLifestage[order(totalSalesByLifestage$Total_Sales,decreasing = FALSE),]
ggplot(totalSalesByLifestage,aes(x=reorder(Lifestage,-Total_Sales),y= Total_Sales,fill=Lifestage)) +
geom_bar(stat="identity",width = 0.5) +
labs(x = "lifestage", y ="Total Sales",title="Total Sales By Lifestage")+
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))+scale_fill_brewer(palette="Dark2")
# total sales by customer premium
totalSalesByPremium <- aggregate(data$TOT_SALES, by=list(LIFESTAGE=data$PREMIUM_CUSTOMER),FUN=sum)
setnames(totalSalesByPremium,c("Premium_Customer","Total_Sales"))
totalSalesByPremium<-totalSalesByPremium[order(totalSalesByPremium$Total_Sales,decreasing = FALSE),]
ggplot(totalSalesByPremium,aes(x=reorder(Premium_Customer,-Total_Sales),y= Total_Sales,fill=Premium_Customer)) +
geom_bar(stat="identity",width = 0.5) +
labs(x = "Premium Customer", y ="Total Sales",title="Total Sales By Premium Customer")+
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))+scale_fill_brewer(palette="Dark2")
#total sales by customer premium and lifestage
totalSalesByPremiumAndLifestage <- aggregate(.~LIFESTAGE+PREMIUM_CUSTOMER, data = data[,c("LIFESTAGE","PREMIUM_CUSTOMER","TOT_SALES")] , sum)
totalSalesByPremiumAndLifestage$Lifestage_Premium <- paste(totalSalesByPremiumAndLifestage$LIFESTAGE,totalSalesByPremiumAndLifestage$PREMIUM_CUSTOMER)
totalSalesByPremiumAndLifestage <- totalSalesByPremiumAndLifestage[,c("Lifestage_Premium","TOT_SALES")]
ggplot(totalSalesByPremiumAndLifestage,aes(x=reorder(Lifestage_Premium,-TOT_SALES),y= TOT_SALES,fill=Lifestage_Premium)) +
geom_bar(stat="identity",width = 0.5) +
labs(x = "Lifestage and Premium", y ="Total Sales",title="Total Sales By Lifestage By Premium")+
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
#### Number of customers by LIFESTAGE and PREMIUM_CUSTOMER
numberOfCustomersByLifestageByPremium <- data.frame(paste(customerData$LIFESTAGE,customerData$PREMIUM_CUSTOMER))
numberOfCustomersByLifestageByPremium <- data.frame(sort(table(numberOfCustomersByLifestageByPremium),decreasing = TRUE ))
setnames(numberOfCustomersByLifestageByPremium,c("Lifestage_Premium","freq"))
ggplot(numberOfCustomersByLifestageByPremium,aes(x=Lifestage_Premium,y = freq,fill=Lifestage_Premium)) +
geom_bar(stat="identity",width = 0.5) +
labs(x = "Lifestage and Premium", y ="Number of Customers",title="Number of Customers By Lifestage By Premium")+
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
#### Average number of units per customer by LIFESTAGE and PREMIUM_CUSTOMER
averageNumberOfUnits <- data.table(data[,c("LIFESTAGE","PREMIUM_CUSTOMER","PROD_QTY")])
averageNumberOfUnits$Lifestage_Premium <-  data.table(paste(data$LIFESTAGE,data$PREMIUM_CUSTOMER))
setnames(averageNumberOfUnits,c("Lifestage","premium","prod_qty","Lifestage_Premium"))
averageNumberOfUnits<- averageNumberOfUnits[,c("Lifestage_Premium","prod_qty")]
setnames(averageNumberOfUnits,c("Lifestage_Premium","PROD_QTY"))
averageNumberOfUnits <- aggregate(.~Lifestage_Premium, data = averageNumberOfUnits[,c("Lifestage_Premium","PROD_QTY")] , mean)
ggplot(averageNumberOfUnits,aes(x=reorder(Lifestage_Premium,-PROD_QTY),y= PROD_QTY,fill=Lifestage_Premium)) +
geom_bar(stat="identity",width = 0.5) +
labs(x = "Lifestage and Premium", y ="Average Units Bought",title="Average Units Per Customer Segment ")+
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
tinytex::reinstall_tinytex()
sales <‐ data[, .(SALES = sum(TOT_SALES)), .(LIFESTAGE, PREMIUM_CUSTOMER)]
#### Total sales by LIFESTAGE and PREMIUM_CUSTOMER
sales <- data[, .(SALES = sum(TOT_SALES)), .(LIFESTAGE, PREMIUM_CUSTOMER)]
#### Create plot
p <- ggplot(data = sales) +
geom_mosaic(aes(weight = SALES, x = product(PREMIUM_CUSTOMER, LIFESTAGE),
↪ fill = PREMIUM_CUSTOMER)) +
#### Create plot
p <- ggplot(data = sales) +
geom_mosaic(aes(weight = SALES, x = product(PREMIUM_CUSTOMER, LIFESTAGE), fill = PREMIUM_CUSTOMER)) +
labs(x = "Lifestage", y = "Premium customer flag", title = "Proportion of
↪ sales") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
#### Plot and label with proportion of sales
p + geom_text(data = ggplot_build(p)$data[[1]], aes(x = (xmin + xmax)/2 , y =
(ymin + ymax)/2, label = as.character(paste(round(.wt/sum(.wt),3)*100,
'%'))))
#### Number of customers by LIFESTAGE and PREMIUM_CUSTOMER
customers <- data[, .(CUSTOMERS = uniqueN(LYLTY_CARD_NBR)), .(LIFESTAGE, PREMIUM_CUSTOMER)][order(-CUSTOMERS)]
#### Create plot
p <- ggplot(data = customers) +
geom_mosaic(aes(weight = CUSTOMERS, x = product(PREMIUM_CUSTOMER, LIFESTAGE), fill = PREMIUM_CUSTOMER)) +
labs(x = "Lifestage", y = "Premium customer flag", title = "Proportion of customers") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
#### Plot and label with proportion of customers
p + geom_text(data = ggplot_build(p)$data[[1]], aes(x = (xmin + xmax)/2 , y =
(ymin + ymax)/2, label = as.character(paste(round(.wt/sum(.wt),3)*100,
'%'))))
#### Average number of units per customer by LIFESTAGE and PREMIUM_CUSTOMER
avg_units <- data[, .(AVG = sum(PROD_QTY)/uniqueN(LYLTY_CARD_NBR)),.(LIFESTAGE, PREMIUM_CUSTOMER)][order(-AVG)]
#### Create plot
ggplot(data = avg_units, aes(weight = AVG, x = LIFESTAGE, fill =PREMIUM_CUSTOMER)) +
geom_bar(position = position_dodge()) +
labs(x = "Lifestage", y = "Avg units per transaction", title = "Units percustomer") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
#### Average price per unit by LIFESTAGE and PREMIUM_CUSTOMER
avg_price <- data[, .(AVG = sum(TOT_SALES)/sum(PROD_QTY)), .(LIFESTAGE,PREMIUM_CUSTOMER)][order(-AVG)]
#### Create plot
ggplot(data = avg_price, aes(weight = AVG, x = LIFESTAGE, fill =PREMIUM_CUSTOMER)) +
geom_bar(position = position_dodge()) +
labs(x = "Lifestage", y = "Avg price per unit", title = "Price per unit") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
#### Perform an independent t-test between mainstream vs premium and budget midageand
#### young singles and couples
pricePerUnit <- data[, price := TOT_SALES/PROD_QTY]
t.test(data[LIFESTAGE %in% c("YOUNG SINGLES/COUPLES", "MIDAGE SINGLES/COUPLES") & PREMIUM_CUSTOMER == "Mainstream", price], data[LIFESTAGE %in% c("YOUNG SINGLES/COUPLES", "MIDAGE SINGLES/COUPLES") & PREMIUM_CUSTOMER != "Mainstream", price], alternative = "greater")
#### Deep dive into Mainstream, young singles/couples
segment1<- data[LIFESTAGE == "YOUNG SINGLES/COUPLES" & PREMIUM_CUSTOMER == "Mainstream",]
other <- data[!(LIFESTAGE == "YOUNG SINGLES/COUPLES" & PREMIUM_CUSTOMER == "Mainstream"),]
#### Brand affinity compared to the rest of the population
quantity_segment1 <- segment1[, sum(PROD_QTY)]
quantity_other <- other[, sum(PROD_QTY)]
quantity_segment1_by_brand <- segment1[, .(targetSegment = sum(PROD_QTY)/quantity_segment1), by = BRAND]
#### Deep dive into Mainstream, young singles/couples
segment1<- data[LIFESTAGE == "YOUNG SINGLES/COUPLES" & PREMIUM_CUSTOMER == "Mainstream",]
other <- data[!(LIFESTAGE == "YOUNG SINGLES/COUPLES" & PREMIUM_CUSTOMER == "Mainstream"),]
#### Brand affinity compared to the rest of the population
quantity_segment1 <- segment1[, sum(PROD_QTY)]
quantity_other <- other[, sum(PROD_QTY)]
quantity_segment1_by_brand <- segment1[, .(targetSegment = sum(PROD_QTY)/quantity_segment1), by = BRAND_NAME]
quantity_other_by_brand <- other[, .(other = sum(PROD_QTY)/quantity_other), by = BRAND_NAME]
brand_proportions <- merge(quantity_segment1_by_brand, quantity_other_by_brand)[, affinityToBrand := targetSegment/other]
brand_proportions[order(-affinityToBrand)]
#### Preferred pack size compared to the rest of the population
quantity_segment1_by_pack <- segment1[, .(targetSegment = sum(PROD_QTY)/quantity_segment1), by = PACK_SIZE]
quantity_other_by_pack <- other[, .(other = sum(PROD_QTY)/quantity_other), by =PACK_SIZE]
pack_proportions <- merge(quantity_segment1_by_pack, quantity_other_by_pack)[, affinityToPack := targetSegment/other]
pack_proportions[order(‐affinityToPack)]
